# 01. 외톨이 숫자 고르기 1

## 1. 문제 정보
- [데일리알고 - 외톨이 숫자 고르기 1](https://dailyalgo.kr/ko/problems/139)

## 2. 소요 시간
- 20분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 처음 읽었을 때, "외톨이 숫자"란 배열에서 단 한 번만 등장하는 숫자를 의미한다는 것을 파악했습니다. 

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 배열의 모든 숫자를 하나씩 확인한다.
2. 각 숫자가 배열에 몇 번 나타나는지 센다.
3. 한 번만 나타나는 숫자를 찾으면 그 것이 외톨이 숫자다.

처음에는 딕셔너리를 사용해야 하나 고민했지만, 이중 for문으로도 충분히 해결할 수 있다고 판단하여 간단한 방법부터 시도해봤습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. `numbers` 배열의 각 원소 `i`를 순서대로 하나씩 꺼내서 확인합니다.
2. 매번 새로운 숫자 `i`를 확인할 때마다 `count` 변수를 0으로 초기화합니다.
3. `numbers` 배열을 처음부터 끝까지 다시 순회하면서, 현재 확인 중인 숫자 `i`와 같은 숫자를 찾을 때마다 `count`를 1씩 증가시킵니다.
4. 내부 for문이 끝나면 `count` 값을 확인합니다. 만약 `count == 1`이라면 해당 숫자 `i`가 배열에서 단 한 번만 등장했다는 의미이므로, 이 숫자가 외톨이 숫자입니다.
5. 외톨이 숫자를 `answer`에 저장하고 `break`로 반복문을 즉시 종료한 뒤 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 외톨이 숫자가 배열의 맨 앞에 있는 경우
    - 첫 번째 반복에서 바로 찾아서 반환하므로 효율적입니다.
- 외톨이 숫자가 배열의 맨 뒤에 있는 경우
    - 거의 모든 원소를 확인한 후에야 찾을 수 있어 시간이 더 걸립니다.
- 배열의 길이가 1인 경우
    - 첫 번째 원소의 cnt가 1이므로 즉시 반환합니다.

## 4. 어려웠던 점 및 해결 과정
- 여러웠던 점 1
    - 처음에는 `count` 변수를 함수 맨 위에 선언했다가, 매번 카운트가 누적되어 잘못된 결과가 나왔습니다. 각 숫자마다 새로 카운트를 세야 하는데, 초기화를 빼먹은 것이 원인이었습니다.
    - `count` 변수를 외부 for문 안쪽에 선언하여, 새로운 숫자를 확인할 때마다 자동으로 0으로 초기화되도록 수정했습니다.
- 어려웠던 점 2
    - 외톨이 숫자를 이미 찾았는데도 계속 나머지 원소들을 확인하느라 시간을 낭비하는 문제가 있었습니다.
    - 외톨이 숫자를 찾는 순간 `break` 문으로 반복문을 즉시 종료하도록 하여 불필요한 연산을 방지했습니다.
- 어려웠던 점 3
    - 이중 for문을 처음 사용해봐서 외부 for문과 내부 for문의 역할이 헷갈렸습니다. 
    - 외부 for문은 "어떤 숫자를 확인할 것인가?"를 결정하고, 내부 for문은 "그 숫자가 몇 번 나오는가?"를 세는 역할이라고 정리하니 이해가 되었습니다.

## 5. 궁금한 점
- 딕셔너리를 사용하면 시간복잡도를 O(n^2)에서 O(n)으로 줄일 수 있다고 하는데, 구체적으로 어떻게 구현할 수 있을까요?
- 딕셔너리를 사용하는 방법보다 더 효율적인 다른 접근 방법이 있을까요?