# 09. 완주하지 못한 선수

## 1. 문제 정보
- [프로그래머스 - 완주하지 못한 선수](https://school.programmers.co.kr/learn/courses/30/lessons/42576)

## 2. 소요 시간
- 20분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 참가자 목록과 완주자 목록을 비교하여 완주하지 못한 단 한 명의 선수를 찾아야 한다는 것을 파악했습니다. 중요한 점은 동명이인이 있을 수 있다는 것입니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 각 참가자의 이름이 몇 번 등장하는지 센다.
2. 완주자 목록에서 각 이름의 등장 횟수를 뺀다.
3. 남은 횟수가 양수인 이름이 완주하지 못한 선수다.

딕셔너리(해시맵)를 사용하면 이름별 등장 횟수를 효율적으로 관리할 수 있습니다. 처음에는 두 배열을 이중 for문으로 비교할까 생각했지만, 동명이인 문제와 효율성을 고려하여 해시맵 방식이 더 적합하다고 판단했습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 빈 딕셔너리 `freq`를 생성합니다. (이름: 빈도수)
2. `participant` 배열의 모든 이름을 순회하면서:
   - `freq.get(name, 0)`으로 현재 빈도수를 가져옵니다. (없으면 0)
   - 1을 더한 값을 `freq[name]`에 저장합니다.
   - 이렇게 하면 각 참가자 이름의 등장 횟수가 기록됩니다.
3. `completion` 배열의 모든 이름을 순회하면서:
   - `freq[name]`에서 1을 뺍니다.
   - 완주한 선수의 이름 빈도를 감소시킵니다.
4. 딕셔너리의 모든 항목을 순회하면서:
   - `count > 0`인 이름을 찾습니다.
   - 이는 참가했지만 완주하지 못한 선수를 의미합니다.
5. 해당 이름을 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 동명이인이 있는 경우 (예: "mislav"가 2명 참가, 1명만 완주)
    - 딕셔너리에서 빈도수를 관리하므로, "mislav"의 빈도가 2→1로 변하고, 최종적으로 `count > 0`이므로 올바르게 찾을 수 있습니다.
- 참가자가 1명뿐인 경우
    - 완주자가 0명이므로, 그 1명이 완주하지 못한 선수로 반환됩니다.
- 완주하지 못한 선수가 배열의 맨 앞이나 맨 뒤에 있는 경우
    - 순서와 무관하게 이름으로 빈도를 관리하므로 위치에 영향받지 않습니다.
- 참가자 목록의 순서와 완주자 목록의 순서가 다른 경우
    - 딕셔너리는 순서와 무관하게 동작하므로 문제없습니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 처음에는 두 배열을 정렬한 후 비교하는 방법을 생각했는데, 동명이인이 있는 경우를 어떻게 처리할지 막막했습니다.
    - 딕셔너리로 빈도수를 관리하면 동명이인 문제를 자연스럽게 해결할 수 있다는 것을 깨달았습니다. 같은 이름이 여러 번 나와도 빈도수가 증가하고, 완주자에서 빈도수가 감소하므로 정확히 계산됩니다.
- 어려웠던 점 2
    - `completion` 배열을 순회할 때 `freq[name] -= 1`을 하는데, 만약 `name`이 딕셔너리에 없으면 KeyError가 발생할까 걱정했습니다.
    - 문제 조건에서 완주자는 모두 참가자 목록에 있다고 보장하므로, 참가자를 먼저 모두 딕셔너리에 추가한 후 완주자를 빼면 KeyError가 발생하지 않습니다.
- 어려웠던 점 3
    - 왜 빈 문자열 `""`을 return으로 넣었는지 의아했습니다.
    - 문제 조건에서 항상 정확히 1명이 완주하지 못한다고 보장하므로, 사실 빈 문자열을 반환하는 경우는 없습니다. 하지만 함수의 구조상 모든 경로에서 반환값이 있어야 하므로 안전장치로 추가한 것입니다.

## 5. 궁금한 점
- 딕셔너리 대신 다른 방법도 있나요?
    - 네, 있습니다. 두 배열을 정렬한 후 순서대로 비교하면 O(n log n) 시간에 해결할 수 있습니다. 하지만 딕셔너리를 사용하면 O(n) 시간에 해결할 수 있어 더 효율적입니다.
- `collections.Counter`를 사용할 수 있나요?
    - 네, 가능합니다. `Counter(participant) - Counter(completion)`처럼 Counter 간 뺄셈 연산을 사용하면 더 간결하게 작성할 수 있습니다. 결과에서 빈도가 양수인 이름을 찾으면 됩니다.
- 시간복잡도는 어떻게 되나요?
    - `participant`를 순회하는데 O(n), `completion`을 순회하는데 O(n-1), 딕셔너리를 순회하는데 최악의 경우 O(n)입니다. 딕셔너리의 삽입과 조회는 평균 O(1)이므로, 전체 시간복잡도는 O(n)입니다. 참가자가 최대 100,000명이므로 충분히 효율적입니다.
- 왜 해시맵을 사용하는 것이 효율적인가요?
    - 해시맵(딕셔너리)은 키로 값을 조회하는 연산이 평균 O(1)이기 때문입니다. 만약 이중 for문으로 비교하면 O(n²)이 되어 참가자가 많을 때 매우 느려집니다.
