# 10. 체스판 다시 칠하기

## 1. 문제 정보
- [백준 - 체스판 다시 칠하기](https://www.acmicpc.net/problem/1018)

## 2. 소요 시간
- 40분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 N×M 크기의 보드에서 8×8 크기의 체스판을 잘라낼 때, 올바른 체스판으로 만들기 위해 다시 칠해야 하는 칸의 최소 개수를 구해야 한다는 것을 파악했습니다.

체스판은 검은색(B)과 흰색(W)이 번갈아 나타나며, 시작 색에 따라 두 가지 패턴이 가능합니다:
1. 왼쪽 위가 'W'로 시작: W-B-W-B-...
2. 왼쪽 위가 'B'로 시작: B-W-B-W-...

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 보드에서 가능한 모든 8×8 영역을 확인한다.
2. 각 8×8 영역에 대해 두 가지 체스판 패턴과 비교한다.
3. 각 패턴과 다른 칸의 개수를 센다.
4. 두 패턴 중 더 적게 칠해도 되는 쪽을 선택한다.
5. 모든 영역 중 최솟값을 찾는다.

체스판 패턴은 `(i + j) % 2`로 판별할 수 있다는 것을 떠올렸습니다. 행과 열의 합이 짝수면 시작 색과 같고, 홀수면 반대 색입니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 최소 다시 칠하는 개수를 저장할 `min_repaint` 변수를 64로 초기화합니다. (8×8 = 64가 최대)
2. 이중 for문으로 8×8 영역의 시작 위치를 모두 탐색합니다:
   - `start_row`: 0부터 `n-8`까지 (행 시작 위치)
   - `start_col`: 0부터 `m-8`까지 (열 시작 위치)
   - `n-8`까지인 이유는 시작점에서 8칸을 확보해야 하기 때문입니다.
3. 각 시작 위치에서:
   - `repaint_w`: 'W'로 시작하는 체스판 패턴과 비교한 칠해야 할 칸 개수
   - `repaint_b`: 'B'로 시작하는 체스판 패턴과 비교한 칠해야 할 칸 개수
   - 두 변수를 0으로 초기화합니다.
4. 8×8 영역 내의 모든 칸 `(i, j)`를 순회합니다:
   - `current`: 현재 칸의 색
   - 'W'로 시작하는 패턴: `(i + j) % 2 == 0`이면 'W', 아니면 'B'
   - 'B'로 시작하는 패턴: `(i + j) % 2 == 0`이면 'B', 아니면 'W'
   - 현재 칸의 색이 기대하는 색과 다르면 카운트를 증가시킵니다.
5. 현재 8×8 영역의 `repaint_w`와 `repaint_b` 중 작은 값과 `min_repaint`를 비교하여 최솟값으로 갱신합니다.
6. 모든 영역을 확인한 후 `min_repaint`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 보드가 정확히 8×8 크기인 경우
    - 시작 위치가 (0, 0) 하나만 존재하며, 그 영역을 확인하여 최솟값을 반환합니다.
- 보드가 이미 완벽한 체스판인 경우
    - 두 패턴 중 하나는 0이 되므로 0을 반환합니다.
- 보드가 모두 같은 색으로 칠해진 경우
    - 두 패턴 모두 32칸씩 다시 칠해야 하므로 32를 반환합니다. (체스판은 절반이 각 색)
- 가장 적게 칠해야 하는 영역이 여러 개인 경우
    - 최솟값만 구하면 되므로 어느 영역이든 상관없습니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 체스판 패턴을 어떻게 표현할지 고민했습니다. 8×8 배열을 미리 만들어두는 방법도 생각했지만 메모리가 낭비될 것 같았습니다.
    - `(i + j) % 2`를 사용하면 수학적으로 체스판 패턴을 판별할 수 있다는 것을 깨달았습니다. 행과 열의 합이 짝수인 칸은 시작 색과 같고, 홀수인 칸은 반대 색입니다.
- 어려웠던 점 2
    - for문의 범위를 설정할 때 실수했습니다. 처음에 `range(n-7)`로 했다가 `range(n-8)`로 수정했습니다.
    - 시작점이 `(0, 0)`부터 `(n-8, m-8)`까지여야 8×8 영역이 보드를 벗어나지 않습니다. 예를 들어 n=10이면 시작점은 0, 1, 2까지 가능하므로 `range(3)` = `range(n-7)`이 맞습니다. (코드는 `range(n-7)`이 맞습니다!)
- 어려웠던 점 3
    - 두 가지 체스판 패턴을 동시에 확인하는 방법이 처음에는 복잡하게 느껴졌습니다.
    - 각 칸마다 두 패턴 모두에 대해 비교하고 각각의 카운터를 유지하면, 한 번의 순회로 두 패턴을 모두 확인할 수 있다는 것을 이해했습니다.
- 어려웠던 점 4
    - `min_repaint = min(min_repaint, repaint_w, repaint_b)` 부분에서 왜 세 개를 비교하는지 헷갈렸습니다.
    - 현재 영역의 두 패턴 중 작은 값과 지금까지의 최솟값을 비교하여 갱신하는 것입니다. `min()` 함수는 여러 인자를 받을 수 있으므로 한 번에 처리할 수 있습니다.

## 5. 궁금한 점
- `(i + j) % 2`로 체스판 패턴을 판별하는 원리는 무엇인가요?
    - 체스판은 대각선 방향으로 같은 색이 나타납니다. 행 인덱스 i와 열 인덱스 j의 합이 짝수인 칸들은 모두 같은 색이고, 홀수인 칸들은 반대 색입니다. 예를 들어 (0,0), (0,2), (1,1), (2,0) 등은 모두 i+j가 짝수이므로 같은 색입니다.
- 시간복잡도는 어떻게 되나요?
    - 가능한 8×8 영역의 개수는 (n-7) × (m-7)이고, 각 영역마다 8×8 = 64칸을 확인하므로 전체 시간복잡도는 O((n-7) × (m-7) × 64) = O(n × m)입니다. n, m이 최대 50이므로 최악의 경우 약 43 × 43 × 64 ≈ 118,000번의 연산으로 충분히 빠릅니다.
- 왜 `min_repaint`의 초기값을 64로 설정했나요?
    - 8×8 체스판의 모든 칸을 다시 칠해야 하는 최악의 경우가 64이기 때문입니다. 실제로는 절반인 32가 최대이지만, 64로 초기화해도 첫 번째 영역을 확인하면 실제 값으로 갱신됩니다.
- 더 효율적인 방법이 있나요?
    - 현재 방법이 완전 탐색이지만, 문제의 제약 조건(n, m ≤ 50)에서는 충분히 효율적입니다. 더 큰 입력에서는 동적 계획법이나 누적 합을 사용하여 최적화할 수 있지만, 이 문제에서는 불필요합니다.
