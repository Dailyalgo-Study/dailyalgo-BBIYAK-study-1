# 03. 완전제곱수 개수 세기

## 1. 문제 정보
- [데일리알고 - 완전제곱수 개수 세기](https://dailyalgo.kr/problems/159)

## 2. 소요 시간
- 20분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 완전제곱수란 어떤 자연수를 제곱한 결과(1, 4, 9, 16, 25...)라는 것을 파악했습니다. `n` 이상 `m` 이하 범위에서 이런 수들의 개수를 세어야 합니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. `n`부터 `m`까지 모든 숫자를 하나씩 확인한다.
2. 각 숫자가 완전제곱수인지 판별한다.
3. 완전제곱수의 개수를 센다.

완전제곱수를 판별하는 방법으로는 제곱근을 구한 후, 그 제곱근을 정수로 만들어 다시 제곱했을 때 원래 숫자와 같은지 확인하는 방법을 생각했습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 완전제곱수의 개수를 저장할 `count` 변수를 0으로 초기화합니다.
2. `range(n, m+1)`을 사용하여 `n`부터 `m`까지의 모든 숫자 `i`를 순회합니다.
   - `m+1`까지 하는 이유는 `m`을 포함하기 위함입니다.
3. 각 숫자 `i`에 대해 완전제곱수인지 판별합니다:
   - `i**0.5`로 제곱근을 구합니다.
   - `int()`로 정수 부분만 추출합니다.
   - 그 정수를 다시 제곱(`**2`)합니다.
   - 원래 숫자 `i`와 같다면 완전제곱수입니다.
4. 완전제곱수라면 `count`를 1 증가시킵니다.
5. 모든 숫자를 확인한 후 `count`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 범위에 완전제곱수가 하나도 없는 경우 (예: n=33, m=35)
    - `count`가 0으로 유지되어 0을 반환합니다.
- 시작값 `n`이나 끝값 `m`이 완전제곱수인 경우 (예: n=9, m=25)
    - `range(n, m+1)`이 양 끝을 포함하므로 정상적으로 카운트됩니다.
- 범위가 좁아서 완전제곱수가 하나만 있는 경우 (예: n=15, m=17로 16만 있음)
    - 정상적으로 1을 반환합니다.
- 완전제곱수가 아닌 수의 제곱근인 경우 (예: 17의 제곱근은 약 4.123)
    - `int(4.123) = 4`, `4**2 = 16 ≠ 17`이므로 완전제곱수가 아니라고 올바르게 판별됩니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 완전제곱수를 어떻게 판별할지 고민했습니다. 모든 자연수를 제곱해서 비교하는 방법도 생각했지만 비효율적이었습니다.
    - 역으로 생각하여 제곱근을 구한 후 정수 부분을 다시 제곱하면 원래 수가 완전제곱수인지 확인할 수 있다는 것을 깨달았습니다.
- 어려웠던 점 2
    - `i**0.5`의 결과가 부동소수점이라 `int()`로 변환하는 과정에서 소수점 아래를 버리는 것이 맞는지 확신이 서지 않았습니다.
    - 예를 들어 16의 제곱근은 정확히 4.0이고, 17의 제곱근은 약 4.123입니다. `int()`는 소수점 아래를 버리므로 각각 4가 되는데, 4를 제곱하면 16이 되어 올바르게 판별할 수 있습니다.
- 어려웠던 점 3
    - `range(n, m+1)`에서 왜 `m+1`을 해야 하는지 처음에는 헷갈렸습니다.
    - 파이썬의 `range()`는 끝 값을 포함하지 않으므로, `m`까지 포함하려면 `m+1`까지 해야 한다는 것을 이해했습니다.

## 5. 궁금한 점
- 더 효율적인 방법이 있을까요?
    - 네, 있습니다. `n`부터 `m`까지 모두 확인하는 대신, `sqrt(n)`부터 `sqrt(m)`까지의 정수만 확인하면 됩니다. 예를 들어 n=9, m=25라면 3부터 5까지만 확인하면 되므로 훨씬 빠릅니다. 시간복잡도가 O(m-n)에서 O(√m - √n)으로 개선됩니다.
- 부동소수점 오차 문제는 없나요?
    - 큰 수에서는 `i**0.5`의 부동소수점 오차 때문에 문제가 생길 수 있습니다. 더 정확한 방법은 `math.isqrt()` 함수(Python 3.8+)를 사용하거나, 정수 연산만으로 판별하는 것입니다.
