# 01. 두 수의 합

## 1. 문제 정보
- [데일리알고 - 두 수의 합](https://dailyalgo.kr/problems/149)

## 2. 소요 시간
- 25분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽었을 때, 서로 다른 두 수를 선택하여 그 합이 목표값 `m` 이하이면서 가장 가까운 값을 찾아야 한다는 것을 파악했습니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 배열에서 서로 다른 두 수의 모든 조합을 확인한다.
2. 각 조합의 합을 구한다.
3. 합이 `m` 이하인 경우만 고려한다.
4. 그 중에서 `m`에 가장 가까운 값(최댓값)을 찾는다.

처음에는 정렬을 해야 하나 고민했지만, 이중 for문으로 모든 쌍을 확인하는 완전 탐색 방법이 가장 확실하다고 판단했습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 결과값을 저장할 `res` 변수를 0으로 초기화합니다.
2. 외부 for문으로 첫 번째 숫자의 인덱스 `i`를 0부터 `n-2`까지 순회합니다.
3. 내부 for문으로 두 번째 숫자의 인덱스 `j`를 `i+1`부터 `n-1`까지 순회합니다.
   - `j`가 `i+1`부터 시작하므로 중복된 조합을 피하고, 서로 다른 두 수를 선택할 수 있습니다.
4. 두 숫자의 합 `s = numbers[i] + numbers[j]`를 계산합니다.
5. 만약 `s <= m`이면서 동시에 `s > res`라면, 즉 현재까지 찾은 값보다 더 큰 값이면서 `m` 이하인 경우, `res`를 `s`로 갱신합니다.
6. 모든 조합을 확인한 후 `res`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 가능한 합이 정확히 `m`과 같은 경우
    - 이 경우 `m`보다 더 큰 값은 없으므로 해당 값이 최종 답이 됩니다.
- 배열의 길이가 2인 경우
    - 오직 하나의 조합만 존재하며, 문제 조건에 따라 항상 `m` 이하인 조합이 존재하므로 그 값이 답입니다.
- 여러 조합의 합이 같은 값인 경우
    - 값만 구하면 되므로 어떤 조합을 선택하든 상관없습니다.
- 가장 작은 두 원소의 합이 답인 경우
    - 초기값 `res = 0`에서 시작하므로 첫 번째 조합부터 정상적으로 갱신됩니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 처음에는 내부 for문을 `range(n)`으로 설정해서 같은 인덱스의 원소를 두 번 사용하거나 중복된 조합(예: (1,2)와 (2,1))을 확인하는 문제가 있었습니다.
    - `range(i+1, n)`으로 설정하여 항상 `j > i`가 되도록 하여 중복을 피하고 서로 다른 두 원소만 선택하도록 했습니다.
- 어려웠던 점 2
    - `res`의 초기값을 어떻게 설정할지 고민했습니다. 배열의 첫 번째 원소로 설정할까 생각했지만, 0으로 설정하는 것이 더 간단했습니다.
    - 문제 조건에서 "가장 작은 두 원소의 합은 항상 `m` 이하"라고 보장하므로, 0에서 시작해도 반드시 적어도 한 번은 갱신됩니다.
- 어려웠던 점 3
    - 조건문에서 `s <= m and s > res`의 순서가 중요하다는 것을 깨달았습니다.
    - 먼저 `s <= m`을 확인하여 유효한 합인지 판단한 후, 그 다음에 현재 최댓값보다 큰지 확인해야 불필요한 비교를 줄일 수 있습니다.

## 5. 궁금한 점
- 이중 for문의 시간복잡도가 O(n²)인데, 더 효율적인 방법이 있을까요?
    - 배열을 정렬한 후 투 포인터 알고리즘을 사용하면 O(n log n)으로 해결할 수 있습니다. 하지만 배열 크기가 100 이하로 작다면 현재 방법도 충분히 효율적입니다.
- 왜 `res`의 초기값을 0으로 설정해도 되나요?
    - 문제에서 "가장 작은 두 원소의 합은 항상 `m` 이하"라고 보장하므로, 반드시 하나 이상의 유효한 조합이 존재합니다. 따라서 0에서 시작해도 첫 번째 유효한 조합을 만나면 갱신됩니다.
