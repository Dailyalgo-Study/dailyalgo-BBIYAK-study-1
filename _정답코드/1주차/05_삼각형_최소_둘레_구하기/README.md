# 05. 삼각형 최소 둘레 구하기

## 1. 문제 정보
- [데일리알고 - 삼각형 최소 둘레 구하기](https://dailyalgo.kr/problems/163)

## 2. 소요 시간
- 35분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 배열에서 서로 다른 세 개의 변을 선택하여 삼각형을 만들 수 있는지 확인하고, 만들 수 있다면 그 중 둘레가 가장 작은 삼각형을 찾아야 한다는 것을 파악했습니다.

삼각형을 만들 수 있는 조건은 "임의의 두 변의 합이 나머지 한 변보다 커야 한다"는 것을 떠올렸습니다. 즉, 세 변 a, b, c에 대해:
- a + b > c
- a + c > b
- b + c > a

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 배열에서 서로 다른 세 원소의 모든 조합을 확인한다.
2. 각 조합이 삼각형 조건을 만족하는지 검증한다.
3. 조건을 만족하는 조합 중에서 둘레(세 변의 합)가 가장 작은 값을 찾는다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 배열의 길이 `n`을 구합니다.
2. 최소 둘레를 저장할 `minP` 변수를 무한대(`float('inf')`)로 초기화합니다.
3. 삼중 for문으로 서로 다른 세 원소의 모든 조합을 탐색합니다:
   - 첫 번째 for문: `i`를 0부터 `n-3`까지 순회
   - 두 번째 for문: `j`를 `i+1`부터 `n-2`까지 순회
   - 세 번째 for문: `k`를 `j+1`부터 `n-1`까지 순회
   - 이렇게 하면 `i < j < k`가 보장되어 중복 없이 모든 조합을 확인합니다.
4. 각 조합의 세 변 `a`, `b`, `c`를 `sides[i]`, `sides[j]`, `sides[k]`로 설정합니다.
5. 삼각형 조건을 확인합니다: `a + b > c and a + c > b and b + c > a`
6. 조건을 만족하면 세 변의 합 `s = a + b + c`를 계산합니다.
7. `s`가 현재 `minP`보다 작으면 `minP`를 갱신합니다.
8. 모든 조합을 확인한 후, `assert`로 유효한 삼각형이 최소 하나 이상 존재하는지 확인합니다.
9. `minP`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 배열에 정확히 3개의 원소만 있고 삼각형을 만들 수 있는 경우
    - 오직 하나의 조합만 존재하며, 그 조합의 둘레가 답이 됩니다.
- 여러 조합이 같은 최소 둘레를 갖는 경우
    - 둘레 값만 반환하면 되므로 어떤 조합을 선택하든 상관없습니다.
- 같은 길이의 변이 여러 개 있는 경우 (예: [1,1,2,2,3,3])
    - 삼중 for문이 인덱스를 기준으로 순회하므로, 같은 값이어도 서로 다른 원소로 취급됩니다.
- 매우 큰 수와 작은 수가 섞여 있는 경우
    - 작은 세 변만으로 삼각형을 만들면 최소 둘레가 되므로, 완전 탐색으로 올바르게 찾을 수 있습니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 삼중 for문의 범위 설정이 복잡했습니다. 특히 각 for문이 어디까지 순회해야 하는지 헷갈렸습니다.
    - 첫 번째는 `n-3`까지, 두 번째는 `n-2`까지, 세 번째는 `n-1`까지 순회해야 뒤의 for문에서 선택할 원소가 남아있다는 것을 이해했습니다.
- 어려웠던 점 2
    - 삼각형 조건을 처음에는 "가장 긴 변이 나머지 두 변의 합보다 작아야 한다"로만 체크했는데, 이것만으로는 부족했습니다.
    - 세 조건을 모두 확인해야 정확하다는 것을 깨달았습니다. 사실 세 변 중 가장 긴 변에 대해서만 확인해도 되지만, 모든 조건을 명시하는 것이 더 명확합니다.
- 어려웠던 점 3
    - `minP`의 초기값을 어떻게 설정할지 고민했습니다. 0으로 설정하면 모든 삼각형의 둘레가 양수이므로 갱신되지 않는 문제가 있었습니다.
    - `float('inf')`로 초기화하면 첫 번째 유효한 삼각형의 둘레로 갱신되고, 그 이후로는 더 작은 값만 갱신되므로 올바르게 동작합니다.

## 5. 궁금한 점
- 삼각형 조건을 세 개 모두 확인해야 하나요?
    - 이론적으로는 세 변을 크기 순으로 정렬한 후, 가장 긴 변이 나머지 두 변의 합보다 작은지만 확인해도 됩니다. 하지만 정렬하지 않는다면 세 조건을 모두 확인하는 것이 안전합니다.
- 시간복잡도가 O(n³)인데 괜찮을까요?
    - n이 최대 1000이므로 최악의 경우 약 10억 번의 연산이 필요합니다. 각 연산이 단순한 비교와 덧셈이므로 실행 시간은 문제없지만, 더 큰 입력에서는 최적화가 필요할 수 있습니다. 배열을 정렬한 후 투 포인터나 이진 탐색을 활용하면 개선할 수 있습니다.
