# 06. 한글 숫자 읽기

## 1. 문제 정보
- [데일리알고 - 한글 숫자 읽기](https://dailyalgo.kr/problems/165)

## 2. 소요 시간
- 25분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 한글로 표기된 숫자 표현(공, 하나, 이, 삼 등)을 0~9의 숫자 문자로 변환해야 한다는 것을 파악했습니다. 각 한글 표현은 정해진 숫자에 매핑됩니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 한글 표현과 숫자의 매핑 관계를 저장한다.
2. 입력 문자열에서 각 한글 표현을 찾아 대응하는 숫자로 치환한다.
3. 모든 한글 표현을 치환한 결과를 반환한다.

파이썬의 딕셔너리를 사용하면 한글-숫자 매핑을 쉽게 표현할 수 있고, 문자열의 `replace()` 메서드로 치환할 수 있습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. `hangul_mapping` 딕셔너리를 생성하여 모든 한글 숫자 표현과 대응하는 숫자 문자를 매핑합니다.
   - 0에 대응: "공", "영"
   - 1에 대응: "하나", "일"
   - ... (2~9까지 동일)
2. 입력 문자열 `hangul_numbers`를 `translate` 변수에 복사합니다.
3. 딕셔너리의 모든 항목을 순회하면서:
   - `hangul`: 한글 표현 (키)
   - `digit`: 숫자 문자 (값)
   - `translate.replace(hangul, digit)`로 문자열에서 `hangul`을 모두 찾아 `digit`으로 치환합니다.
   - 치환된 결과를 다시 `translate`에 저장합니다.
4. 모든 한글 표현을 치환한 후 `translate`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 같은 숫자에 대한 서로 다른 표현이 섞여 있는 경우 (예: "일하나")
    - 딕셔너리에 모두 매핑되어 있으므로 순서대로 치환됩니다. "일"→"1", "하나"→"1"이 되어 "11"이 됩니다.
- 한 자리 숫자만 있는 경우 (예: "영")
    - 정상적으로 "0"으로 치환됩니다.
- 여러 자리 숫자가 이어진 경우 (예: "공하나칠오여덟")
    - 각 한글 표현이 순서대로 치환되어 "01758"이 됩니다.
- 같은 한글 표현이 연속으로 나오는 경우 (예: "영영")
    - `replace()`는 문자열에서 모든 일치하는 부분을 치환하므로 "00"이 됩니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 처음에는 if-elif 문으로 모든 경우를 나열하려고 했는데, 코드가 너무 길어지고 반복적이었습니다.
    - 딕셔너리를 사용하여 매핑 관계를 한 곳에 정의하고, for문으로 순회하면서 치환하는 방식으로 코드를 간결하게 만들었습니다.
- 어려웠던 점 2
    - `replace()` 메서드가 원본 문자열을 수정하는지, 새로운 문자열을 반환하는지 헷갈렸습니다.
    - 파이썬의 문자열은 불변(immutable)이므로 `replace()`는 새로운 문자열을 반환합니다. 따라서 `translate = translate.replace(...)`처럼 결과를 다시 할당해야 합니다.
- 어려웠던 점 3
    - 긴 한글 표현(예: "여덟")과 짧은 한글 표현(예: "팔")이 섞여 있을 때 치환 순서가 영향을 미치는지 고민했습니다.
    - 문제에서 유효한 한글 숫자 표현만 입력으로 주어진다고 했으므로, 치환 순서와 무관하게 올바르게 동작합니다. 또한 각 표현이 겹치지 않으므로 문제가 없습니다.

## 5. 궁금한 점
- 딕셔너리의 순회 순서가 중요한가요?
    - 이 문제에서는 각 한글 표현이 서로 겹치지 않으므로 순서가 중요하지 않습니다. Python 3.7+에서는 딕셔너리가 삽입 순서를 유지하지만, 이 문제에서는 영향이 없습니다.
- `replace()` 대신 다른 방법도 있나요?
    - 네, 정규표현식(regex)을 사용할 수도 있습니다. 하지만 이 문제에서는 단순 문자열 치환으로 충분하므로 `replace()`가 더 간단하고 직관적입니다.
- 시간복잡도는 어떻게 되나요?
    - 딕셔너리에 20개의 항목이 있고, 각 `replace()` 연산은 문자열 길이 n에 대해 O(n)입니다. 따라서 전체 시간복잡도는 O(20 × n) = O(n)입니다. n이 최대 100이므로 매우 빠릅니다.
