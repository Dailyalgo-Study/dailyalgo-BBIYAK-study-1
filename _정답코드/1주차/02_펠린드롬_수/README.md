# 02. 팰린드롬 수

## 1. 문제 정보
- [데일리알고 - 팰린드롬 수](https://dailyalgo.kr/problems/158)

## 2. 소요 시간
- 10분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 팰린드롬 수란 앞에서 읽으나 뒤에서 읽으나 같은 숫자를 의미한다는 것을 파악했습니다. 예를 들어 131은 앞에서 읽어도 131, 뒤에서 읽어도 131입니다.

가장 먼저 떠오른 방법은 다음과 같았습니다.
1. 숫자를 문자열로 변환한다.
2. 문자열을 뒤집는다.
3. 원본 문자열과 뒤집은 문자열을 비교한다.

파이썬의 문자열 슬라이싱 기능(`[::-1]`)을 사용하면 간단하게 문자열을 뒤집을 수 있다는 것을 떠올렸습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. `str(n)`을 사용하여 정수 `n`을 문자열 `s`로 변환합니다.
   - 예: 131 → "131"
2. `s[::-1]`을 사용하여 문자열 `s`를 뒤집습니다.
   - 예: "131" → "131"
3. 원본 문자열 `s`와 뒤집은 문자열 `s[::-1]`을 비교합니다.
4. 두 문자열이 같으면 `True`를, 다르면 `False`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 한 자리 숫자인 경우 (예: 7)
    - 한 자리 숫자는 앞뒤가 없으므로 항상 팰린드롬 수입니다. "7"을 뒤집어도 "7"이므로 `True`를 반환합니다.
- 짝수 자리 팰린드롬 수인 경우 (예: 1221)
    - "1221"을 뒤집으면 "1221"이므로 정상적으로 `True`를 반환합니다.
- 홀수 자리 팰린드롬 수인 경우 (예: 12321)
    - "12321"을 뒤집으면 "12321"이므로 정상적으로 `True`를 반환합니다.
- 앞자리에 0이 없는 일반 숫자인 경우
    - 자연수는 앞에 0이 올 수 없으므로, 문자열로 변환해도 "012" 같은 형태가 되지 않습니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 처음에는 숫자를 직접 조작해서 뒤집어야 하나 고민했습니다. 각 자릿수를 추출하고 다시 조합하는 방법이 복잡하게 느껴졌습니다.
    - 문자열로 변환하면 파이썬의 슬라이싱 기능을 활용할 수 있다는 것을 깨닫고, `str(n)`과 `[::-1]`을 사용하여 간단하게 해결했습니다.
- 어려웠던 점 2
    - `[::-1]`이 정확히 어떤 의미인지 헷갈렸습니다.
    - 슬라이싱의 형식이 `[시작:끝:간격]`인데, `[::-1]`은 "처음부터 끝까지, -1씩 이동" 즉 역순으로 읽는다는 의미라는 것을 이해했습니다.
- 어려웠던 점 3
    - 비교 연산자 `==`가 문자열에도 사용할 수 있는지 확신이 서지 않았습니다.
    - 파이썬에서는 문자열도 `==` 연산자로 내용을 비교할 수 있으며, 각 문자를 순서대로 비교한다는 것을 확인했습니다.

## 5. 궁금한 점
- 문자열로 변환하지 않고 숫자로 직접 판별하는 방법도 있을까요?
    - 네, 가능합니다. 숫자를 10으로 나눈 나머지를 계속 추출하여 뒤집은 숫자를 만든 후 원본과 비교하는 방법이 있습니다. 하지만 코드가 복잡해지므로 문자열 변환이 더 직관적입니다.
- 슬라이싱 `[::-1]`의 시간복잡도는 어떻게 되나요?
    - 문자열 길이를 n이라 할 때 O(n)입니다. 모든 문자를 역순으로 복사하기 때문입니다. 비교 연산도 O(n)이므로 전체 시간복잡도는 O(n)입니다.
