# 04. 서브블록 합의 최대와 최소 1

## 1. 문제 정보
- [데일리알고 - 서브블록 합의 최대와 최소 1](https://dailyalgo.kr/problems/161)

## 2. 소요 시간
- 30분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 2차원 배열에서 모든 2×2 크기의 정사각형 부분 배열을 찾아, 각각의 원소 합 중에서 최댓값과 최솟값을 구해야 한다는 것을 파악했습니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 2차원 배열을 순회하면서 가능한 모든 2×2 서브블록의 위치를 찾는다.
2. 각 서브블록의 4개 원소의 합을 구한다.
3. 합들 중에서 최댓값과 최솟값을 추적한다.

2×2 서브블록의 왼쪽 위 모서리 위치 `(i, j)`를 기준으로 하면, 4개의 원소는 `(i,j)`, `(i,j+1)`, `(i+1,j)`, `(i+1,j+1)`이 됩니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 배열의 행 개수 `m`과 열 개수 `n`을 구합니다.
2. 첫 번째 서브블록(왼쪽 위의 2×2 블록)의 합을 계산하여 `max_sum`과 `min_sum`을 초기화합니다.
   - `array[0][0] + array[0][1] + array[1][0] + array[1][1]`
3. 이중 for문으로 가능한 모든 서브블록의 시작 위치를 탐색합니다:
   - 외부 for문: `i`를 0부터 `m-2`까지 순회 (행 방향)
     - `m-2`까지인 이유는 `i+1` 행이 존재해야 하기 때문입니다.
   - 내부 for문: `j`를 0부터 `n-2`까지 순회 (열 방향)
     - `n-2`까지인 이유는 `j+1` 열이 존재해야 하기 때문입니다.
4. 각 위치 `(i, j)`에서 2×2 서브블록의 합 `s`를 계산합니다:
   - `s = array[i][j] + array[i][j+1] + array[i+1][j] + array[i+1][j+1]`
5. `s`가 현재 `max_sum`보다 크면 `max_sum`을 갱신합니다.
6. `s`가 현재 `min_sum`보다 작으면 `min_sum`을 갱신합니다.
7. 모든 서브블록을 확인한 후 `[max_sum, min_sum]` 형태로 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 배열이 정확히 2×2 크기인 경우
    - 오직 하나의 서브블록만 존재하므로, 최댓값과 최솟값이 동일합니다. 초기값으로 설정되고 더 이상 갱신되지 않아 올바른 결과가 나옵니다.
- 모든 원소가 같은 값인 경우 (예: 모두 0)
    - 모든 서브블록의 합이 동일하므로, 최댓값과 최솟값이 같은 값으로 반환됩니다.
- 음수가 포함된 경우
    - 음수가 많이 포함된 서브블록이 최솟값이 되며, 비교 연산이 정상적으로 작동합니다.
- 매우 큰 양수와 음수가 섞여 있는 경우
    - 초기값을 첫 번째 서브블록으로 설정했으므로, 실제 범위 내의 값으로 시작하여 정확한 최대/최소를 찾을 수 있습니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 2차원 배열의 인덱스를 다루는 것이 헷갈렸습니다. `array[i][j]`에서 `i`가 행인지 열인지 혼동했습니다.
    - `m = len(array)`는 행 개수, `n = len(array[0])`은 열 개수이고, `array[행][열]` 순서로 접근한다는 것을 명확히 이해했습니다.
- 어려웠던 점 2
    - for문의 범위를 `range(m)`과 `range(n)`으로 설정했다가 인덱스 에러가 발생했습니다.
    - 2×2 서브블록을 만들려면 `i+1`과 `j+1` 인덱스가 유효해야 하므로, `range(m-1)`과 `range(n-1)`로 수정해야 했습니다.
- 어려웠던 점 3
    - 최댓값과 최솟값의 초기값을 어떻게 설정할지 고민했습니다. `float('inf')`와 `float('-inf')`를 사용할까 생각했습니다.
    - 첫 번째 서브블록의 합으로 초기화하는 것이 더 자연스럽고, 실제 데이터 범위 내의 값으로 시작할 수 있어서 안전합니다.

## 5. 궁금한 점
- 왜 초기값을 첫 번째 서브블록으로 설정했나요?
    - `float('inf')`나 `float('-inf')`를 사용할 수도 있지만, 실제 배열의 값으로 초기화하면 더 명확하고 안전합니다. 또한 for문에서 첫 번째 서브블록을 다시 확인하더라도 조건문에서 같은 값이므로 갱신되지 않아 문제가 없습니다.
- 시간복잡도는 어떻게 되나요?
    - 이중 for문으로 모든 서브블록을 확인하므로 O(m × n)입니다. m과 n이 최대 1000이므로 최악의 경우 약 100만 번의 연산이 필요하지만, 각 연산이 단순하므로 충분히 빠릅니다.
