# 08. 최빈값 찾기

## 1. 문제 정보
- [데일리알고 - 최빈값 찾기](https://dailyalgo.kr/problems/171)

## 2. 소요 시간
- 25분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 배열에서 가장 많이 등장하는 숫자(최빈값)를 찾아야 하며, 동률인 경우 가장 작은 수를 반환해야 한다는 것을 파악했습니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 배열의 각 숫자가 몇 번 등장하는지 센다.
2. 가장 많이 등장한 횟수를 찾는다.
3. 그 횟수로 등장하는 숫자들 중 가장 작은 숫자를 선택한다.

파이썬의 딕셔너리를 사용하면 각 숫자의 등장 횟수를 효율적으로 저장할 수 있습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 빈 딕셔너리 `freq`를 생성합니다. (숫자: 등장 횟수)
2. `numbers` 배열의 모든 숫자를 순회하면서:
   - `freq.get(num, 0)`으로 현재 등장 횟수를 가져옵니다. (없으면 0)
   - 1을 더한 값을 `freq[num]`에 저장합니다.
   - 이렇게 하면 각 숫자의 등장 횟수가 딕셔너리에 기록됩니다.
3. 최대 등장 횟수를 저장할 `max_freq`를 0으로, 결과를 저장할 `result`를 0으로 초기화합니다.
4. 딕셔너리의 모든 항목을 순회하면서:
   - `num`: 숫자
   - `count`: 해당 숫자의 등장 횟수
   - 만약 `count > max_freq`라면 (더 많이 등장한 숫자를 발견)
     - `max_freq`를 `count`로 갱신
     - `result`를 `num`으로 갱신
5. 모든 항목을 확인한 후 `result`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- 모든 숫자가 한 번씩만 등장하는 경우 (예: [1,2,3,4])
    - 모두 같은 빈도(1)를 가지므로, 먼저 순회된 숫자가 선택됩니다. 그러나 문제에서 "가장 작은 수"를 반환해야 하는데, 딕셔너리 순회 순서가 보장되지 않으면 문제가 될 수 있습니다.
    - **주의**: 현재 코드는 동률일 때 가장 작은 수를 보장하지 않습니다! 조건문을 `count > max_freq`로 했기 때문에, 같은 빈도의 숫자는 업데이트되지 않습니다.
- 음수가 포함된 경우 (예: [-2, -2, 5, 5])
    - 음수도 정상적으로 딕셔너리 키가 될 수 있으므로, 빈도 계산은 올바르게 동작합니다.
- 배열에 하나의 숫자만 있는 경우 (예: [7])
    - 그 숫자가 최빈값이 되어 올바르게 반환됩니다.
- 여러 숫자가 같은 최대 빈도를 갖는 경우
    - **현재 코드의 한계**: `count > max_freq` 조건 때문에, 딕셔너리 순회 시 처음 만나는 최대 빈도의 숫자를 반환합니다. 동률일 때 가장 작은 수를 보장하려면 추가 로직이 필요합니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 딕셔너리에 숫자가 이미 존재하는지 확인하고 카운트를 증가시키는 로직을 어떻게 작성할지 고민했습니다.
    - `freq.get(num, 0) + 1` 방식을 사용하면 한 줄로 간단하게 처리할 수 있다는 것을 배웠습니다. `get()`의 두 번째 인자는 키가 없을 때 반환할 기본값입니다.
- 어려웠던 점 2
    - 최빈값을 찾을 때 딕셔너리를 어떻게 순회해야 할지 막막했습니다.
    - `.items()`를 사용하면 키-값 쌍을 함께 순회할 수 있어서 `for num, count in freq.items()`로 간단하게 작성할 수 있었습니다.
- 어려웠던 점 3
    - 동률일 때 가장 작은 수를 선택해야 한다는 조건을 처음에 놓쳤습니다.
    - 현재 코드는 `count > max_freq`만 확인하므로 동률 처리가 완벽하지 않습니다. `count > max_freq or (count == max_freq and num < result)`로 수정하면 동률일 때도 더 작은 숫자를 선택할 수 있습니다.

## 5. 궁금한 점
- 딕셔너리 대신 다른 자료구조를 사용할 수 있나요?
    - Python의 `collections.Counter`를 사용하면 더 간단하게 빈도를 계산할 수 있습니다. `Counter(numbers).most_common()`으로 최빈값을 쉽게 찾을 수 있지만, 동률 처리는 여전히 추가 로직이 필요합니다.
- 동률일 때 가장 작은 수를 확실히 보장하려면?
    - 조건문을 `if count > max_freq or (count == max_freq and num < result):`로 수정하거나, 최빈값들을 모두 찾은 후 그 중 최솟값을 선택하는 방법이 있습니다. 또는 딕셔너리를 키로 정렬한 후 순회하면 작은 숫자부터 확인할 수 있습니다.
- 시간복잡도는 어떻게 되나요?
    - 배열을 한 번 순회하여 빈도를 계산하므로 O(n), 딕셔너리를 순회하여 최빈값을 찾으므로 O(k) (k는 서로 다른 숫자의 개수). 전체 시간복잡도는 O(n + k) = O(n)입니다. 공간복잡도는 딕셔너리에 O(k)입니다.
