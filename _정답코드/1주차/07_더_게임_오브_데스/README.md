# 07. 더 게임 오브 데스

## 1. 문제 정보
- [데일리알고 - 더 게임 오브 데스](https://dailyalgo.kr/problems/170)

## 2. 소요 시간
- 20분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

문제를 읽고 "더 게임 오브 데스"는 현재 사람이 다음 사람을 지목하고, 지목받은 사람이 또 다음 사람을 지목하는 과정을 `k`번 반복하는 게임이라는 것을 파악했습니다.

가장 직관적으로 떠오른 방법은 다음과 같았습니다.
1. 1번 사람부터 시작한다.
2. 현재 사람이 지목한 사람을 배열에서 찾는다.
3. 지목받은 사람이 다음 차례가 된다.
4. 이 과정을 `k`번 반복한다.
5. 최종적으로 지목받은 사람의 번호를 반환한다.

시뮬레이션 방식으로 게임을 단계별로 진행하면서 현재 차례인 사람을 추적하면 됩니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. 현재 차례인 사람의 번호를 저장할 `current` 변수를 1로 초기화합니다. (게임은 항상 1번부터 시작)
2. `k`번 반복하는 for문을 실행합니다.
3. 각 반복마다:
   - `current` 번 사람이 지목한 사람의 번호는 `target[current-1]`입니다.
     - 배열 인덱스는 0부터 시작하지만, 사람 번호는 1부터 시작하므로 `-1`을 해줍니다.
   - `current`를 지목받은 사람의 번호로 갱신합니다.
4. `k`번 반복이 끝나면 `current`에는 최종적으로 지목받은 사람의 번호가 저장되어 있습니다.
5. `current`를 반환합니다.

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.

- `k`가 1인 경우
    - 1번이 지목한 사람이 바로 답이 됩니다. for문이 한 번만 실행되어 올바르게 동작합니다.
- 지목 과정이 순환하는 경우 (예: 1→2→4→1→2→4...)
    - 계속 반복되더라도 `k`번만 실행하므로 정확한 위치를 찾을 수 있습니다.
- 모든 사람이 같은 사람을 지목하는 경우 (예: 모두 1번을 지목)
    - 한 번 지목된 후에는 계속 같은 사람을 반복하게 됩니다.
- `k`가 매우 큰 경우 (최대 10,000)
    - 단순 반복이므로 시간복잡도 O(k)로 충분히 빠릅니다.

## 4. 어려웠던 점 및 해결 과정
- 어려웠던 점 1
    - 사람 번호가 1부터 시작하는데 배열 인덱스는 0부터 시작해서 혼란스러웠습니다.
    - `target[current-1]`로 접근해야 한다는 것을 명확히 이해했습니다. 예를 들어 1번 사람이 지목한 사람은 `target[0]`에 저장되어 있습니다.
- 어려웠던 점 2
    - 처음에는 지목 과정을 리스트에 저장하려고 했는데, 불필요하게 복잡했습니다.
    - `k`번째 지목만 필요하므로, 중간 과정을 저장하지 않고 `current` 변수만 갱신하면 된다는 것을 깨달았습니다.
- 어려웠던 점 3
    - for문에서 `range(k)`를 사용했는데, 반복 변수를 사용하지 않아서 언더스코어(`_`)를 사용하는 것이 관례라는 것을 배웠습니다.
    - `for _ in range(k):`처럼 작성하면 "이 변수는 사용하지 않는다"는 의미를 명확히 전달할 수 있습니다.

## 5. 궁금한 점
- 순환 구조를 미리 감지하여 최적화할 수 있나요?
    - 네, 가능합니다. 지목 과정에서 순환이 발생하면 주기를 찾아서 `k`를 주기로 나눈 나머지만 계산하면 됩니다. 하지만 `k`가 최대 10,000이고 각 연산이 O(1)이므로 현재 방법도 충분히 효율적입니다.
- 1-based 인덱스와 0-based 인덱스를 다룰 때 주의할 점은?
    - 항상 변환이 필요한 부분을 명확히 파악해야 합니다. 사람 번호를 배열 인덱스로 변환할 때는 `-1`을, 반대로 배열 인덱스를 사람 번호로 변환할 때는 `+1`을 해야 합니다. 주석을 달아두면 실수를 줄일 수 있습니다.
