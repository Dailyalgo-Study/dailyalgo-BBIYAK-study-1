# **더 게임 오브 데스**

## **1. 문제 정보**

- [데일리알고 - 더 게임 오브 데스](https://dailyalgo.kr/problems/163)

## **2. 소요 시간**

- 20분

---

## **3. 풀이 설명**

### **💡 아이디어 도출 과정**

> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.
> 

이 문제는 n명의 참가자가 각각 **“자신이 지목할 다음 사람”을 미리 정해놓은 상태**에서

1번 참가자부터 시작해 **k번 지목이 이루어졌을 때, 마지막으로 지목된 사람 번호를 구하는 문제**입니다.

즉,

- target[i]는 (i+1)번 참가자가 지목할 사람 번호를 의미합니다.
- 1번 참가자부터 시작해서 **k번 이동**하면 됩니다.

예를 들어,

target = [2,4,5,3,4], k = 7이면

1 → 2 → 4 → 3 → 5 → 4 → 3 → 5

총 7번의 지목 후 **5번**이 마지막에 지목된 사람이 됩니다.

문제의 크기가 작기 때문에(최대 n=100, k=10,000),

**단순한 반복문 시뮬레이션**으로 충분히 해결 가능합니다.

---

### **⚙️ 구현 로직의 동작 과정**

> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.
> 
1. **시작 위치 설정**
    - 게임은 항상 **1번 참가자**부터 시작합니다.
    - 따라서 cur = 1로 초기화합니다.
2. **k번 반복하며 다음 사람으로 이동**
    - cur = target[cur - 1];
        
        (target이 0-index 기반이므로 -1을 해줍니다.)
        
    - 이 과정을 **k번 반복**합니다.
3. **결과 반환**
    - k번째 지목이 완료된 후 cur이 곧 최종 지목된 사람 번호가 됩니다.

---

### **✅ 예시 코드**

```
import java.util.*;

public class Solution {
    public int solution(int[] target, int k) {
        int cur = 1; // 1번 참가자부터 시작
        for (int i = 0; i < k; i++) {
            cur = target[cur - 1]; // 현재 참가자가 지목한 사람으로 이동
        }
        return cur; // 마지막으로 지목된 사람
    }

}
```

---

### **✅ 엣지 케이스에 대한 고려 사항**

> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.
> 
1. **자기 자신을 지목하는 경우 없음**
    
    문제 조건상 target[i] != i + 1 이므로 무한 루프가 발생하지 않습니다.
    

---

## **4. 어려웠던 점 및 해결 과정**

처음 문제를 읽을 때 “지목이 몇 번 일어나는가?“와 “누가 지목받는가?“를 헷갈리기 쉬웠습니다.

하지만 예시를 직접 손으로 써보면서 **‘k번의 지목 후 마지막으로 지목받은 사람’**이라는 점을 명확히 이해했습니다.

---

## **5. 궁금한 점**

k의 범위가 훨씬 커진다면(예: 10억 이상), 어떻게 문제를 풀이해야할까요