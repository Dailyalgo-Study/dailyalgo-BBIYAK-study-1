# **01. O(N^2) 정렬 2**

# **1. 문제 정보**

- [데일리알고 - O(N^2) 정렬 2](https://dailyalgo.kr/ko/problems/173)

# **2. 소요 시간**

- 20분

# **3. 풀이 설명**

## **💡 아이디어 도출 과정**

- 이 문제는 시간복잡도가 O(N^2)인 알고리즘을 사용해 내림차순으로 정렬하는 문제입니다.
- 시간복잡도가 O(N^2)인 알고리즘 종류를 알아보겠습니다.
    - 버블 정렬
        - 인접한 두 원소를 반복적으로 비교해가며 더 큰 값을 뒤로 보내는 방식
        - 가장 큰 값이 반복될 떄마다 배열의 끝으로 이동하게 되며, 전체 데이터 N에 대해 n(n-1)/2의 비교가 이루어져 O(N^2)의 시간 복잡도를 갖음.
    - 선택 정렬
        - 데이터에서 최솟값 혹은 최댓값을 반복적으로 찾아 1번, 2번 위치에 순서대로 배치하는 방식
        - 매 회차마다 전체 원소를 비교하여 최소값을 찾기 때문에 모든 경우에서 O(N^2)의 복잡도를 갖음.
    - 삽입 정렬
        - 현재 부분집합이 항상 정렬된 상태를  유지하도록, 새로운 원소를 올바른 위치에 삽입하면서 정렬을 진행.
        - 최악의 경우 O(N^2), 정렬된 배열은 O(N)시간 가능.
- 이번에는 구현이 쉬운 버블 정렬을 이용해서 문제를 풀이 하겠습니다.

## **⚙️ 구현 로직의 동작 과정**

- 버블 정렬은 인접한 두 원소의 크기를 비교하여 더 큰 수를 왼쪽으로 보내면 됩니다.(내림차순 정렬)
- 구현이 쉽기에 버블 정렬을 구현해 봤습니다.

```java
				for (int i = 0; i < numbers.length - 1; i++) {
            for (int j = 0; j < numbers.length - 1 - i; j++) {
                if (numbers[j] < numbers[j + 1]) {
                    int temp = numbers[j];
                    numbers[j] = numbers[j + 1];
                    numbers[j + 1] = temp;
                }
            }
        }
```

## **✅ 엣지 케이스에 대한 고려 사항**

- 현재 인덱스 값과 인덱스 + 1 값과 비교해야 하기에 탐색 범위를 0~numbers.length - 1 까지로 제한해야 합니다.
- j 같은 경우는 이미 정렬한 부분을 제외하기 위해서 0 ~ numbers.length - 1 - i 까지로 제한해야 합니다.

## **4. 어려웠던 점 및 해결 과정**

- O(N^2) 알고리즘을 구현해본 경험이 매우 적었기에 이번에 다시 한 번 O(N^2) 정렬 알고리즘을 공부했습니다.

## 5. 궁금한 점

- 회사 코딩테스트에서 선택 정렬, 버블 정렬, 삽입 정렬등을 사용하는 경우가 있을까요?