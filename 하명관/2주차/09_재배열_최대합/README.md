## 1. 문제 정보

- [백준 - 덩치](https://www.acmicpc.net/problem/7568)

## 2. 소요 시간

- 35분

## 3. 풀이 설명

### 💡 아이디어 도출 과정

- 문제 분석
    - 이 문제는 몸무게와 키가 주어질 때, 다른 사람들보다 몸무게와 키가 둘다 크다면 덩치가 더크다라고 한다.
    - 몸무게는 크지만 키가 작을 경우 덩치가 같다라고 본다.
    - N 명의 집단에서 자기보다 덩치가 큰 사람이 k명이면 자신의 덩치 등수는 k + 1이다.
    - 같은 덩치 등수를 가진 사람도 여러명 가능하다.
    - 주어진 사람 순서대로 등수를 출력 하면 된다.
- 문제 풀이
    - 이차원 배열(몸무게, 키, 등수값)를 입력해주면 된다.
    - 만약 지금 사람과 다른 모든 사람들을 비교할때 자신이 키와 몸무게 둘다 작을 경우 등수를 증가하면 된다.

### ⚙️ 구현 로직의 동작 과정

- 이차원 배열(몸무게, 키, 등수값)를 입력해주면 된다.
    
    ```java
            Scanner sc = new Scanner(System.in);
            N = sc.nextInt();
    
            input = new int[N][3];
    
            for (int i = 0; i < N; i++) {
                int weight = sc.nextInt();
                int height = sc.nextInt();
    
                input[i][0] = weight;
                input[i][1] = height;
                input[i][2] = 1;
            }
            
    ```
    
- 현재 사람과 다른 모두를 비교하여 키와 몸무게 둘다 작은 경우를 찾아서 등수를 증가하면 된다.
    
    ```java
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < N; j++) {
                    if (i == j) continue;
                    if (input[i][0] < input[j][0] && input[i][1] < input[j][1]) {
                        input[i][2]++;
                    }
                }
            }
    ```
    
- 출력하면 된다.
    
    ```java
            for (int[] r : input) {
                System.out.print(r[2] + " ");
            }
    ```
    

### ✅ 엣지 케이스에 대한 고려 사항

- 이중 반복문을 사용할 때 동일한 사람을 비교할 필요가 없으니 둘이 값이 같은경우 continue를 사용하여 불필요한 반복 제거.

## 4. 어려웠던 점 및 해결 과정

- 정렬을 통한 문제를 풀이하려고 했지만 정렬보다는 모든 경우의 수를 구하는 BruteForce 문제이었음.

# 07. 최대 적재하중

## 1. 문제 정보

- [데일리알고 - 최대 적재하중](https://dailyalgo.kr/ko/problems/187)

## 2. 소요 시간

- 20분

## 3. 풀이 설명

### 💡 아이디어 도출 과정

- 묶음 개수 * 가장 약한 로프의 하중으로 결정
- 각 로프를 가장 약한 로프를 가정하고 하중  * 해당 로프 이상의 개수를 계산하여 최대 하중을 찾는다.

### ⚙️ 구현 로직의 동작 과정

- 로프 배열을 로프 하중을 기준으로 오름차순으로 정렬하자.
    
    ```java
            Arrays.sort(ropes);
            int n = ropes.length;
    ```
    
- 뒤에서부터 현재 로프를 기준으로 가능한 모든 로프를 포함시켜 계산하자.
    
    ```java
            for (int i = 0; i < ropes.length; i++) {
                int weight = ropes[i] * (ropes.length - i);
                if (answer < weight) {
                    answer = weight;
                }
            }
    ```
    

### ✅ 엣지 케이스에 대한 고려 사항

## 4. 어려웠던 점 및 해결 과정

- 문제를 분석하는데 어려움이 있었다. 로프 최대 하중을 찾는 개념을 이해하기가 어려웠다.

## 5. 궁금한 점

- 문제를 분석하는 실력을 어떤 방법으로 늘릴 수 있는지 궁금합니다.

# 08. 필요한 구명보트

## 1. 문제 정보

- [데일리알고 - 필요한 구명보트](https://dailyalgo.kr/ko/problems/188)

## 2. 소요 시간

- 20분

## 3. 풀이 설명

### 💡 아이디어 도출 과정

- 한 보트에는 **최대 두 명**만 탈 수 있고, 두 사람의 무게 합이 limit을 초과해서는 안 된다.
- 따라서 가장 효율적인 방법은 가장 무거운 사람과 가장 가벼운 사람을 함께 태우는 방식이다.
- 만약 두 사람의 무게 합이 limit을 초과하면, 무거운 사람은 반드시 혼자 타야 한다.

### ⚙️ 구현 로직의 동작 과정

- people 배열을 몸무게 기준 오름차순 정렬
    
    ```java
    Arrays.sort(people);
    int left = 0;
    int right = people.length - 1;
    int answer = 0;
    ```
    
- 가장 가벼운 사람(left)과 가장 무거운 사람(right)의 무게 합을 확인한다.
- 두 사람의 합이 limit 이하이면 두 사람을 함께 보내고 limit 초과면 무거운 사람만 태운다.
    
    ```java
    while (left <= right) {
        if (people[left] + people[right] <= limit) {
            left++;
            right--;
        } else {
            right--;
        }
        answer++;
    }
    
    ```
    

### ✅ 엣지 케이스에 대한 고려 사항

- 합의 무게가 limit을 초과할때 한명만 태워야함.

## 4. 어려웠던 점 및 해결 과정

- 두사람이 투포인터를 이용하면 되겠다고 생각했음.

## 5. 궁금한 점

- 만약 두사람이 아니라 세명의 사람을 태워야 한다면 모든 배열을 탐색하는 방향으로 해야할까요?

# 09. 재배열 최대합

## 1. 문제 정보

- [데일리알고 - 재배열 최대합](https://dailyalgo.kr/ko/problems/191)

## 2. 소요 시간

- 20분

## 3. 풀이 설명

### 💡 아이디어 도출 과정

- 배열 A, B가 있을 때 배열 내적값 = A[0]*B[0] + A[1]*B[1] + ... + A[n-1]*B[n-1]
- 내적값을 최대로 만들려면 큰 수끼리 곱해야 하므로 A와 B를 모두 오름차순 정렬한 뒤 같은 인덱스끼리 곱하면 된다.

### ⚙️ 구현 로직의 동작 과정

- 배열 A, B를 오름차순 정렬
- 각 인덱스별로 A[i] * B[i]를 더해 총합을 구함
- 총합(sum)이 곧 “배열 내적값”의 최댓값이 됨

### ✅ 엣지 케이스에 대한 고려 사항

## 4. 어려웠던 점 및 해결 과정

- 큰 수끼리 곱하면 최대값이 나오기 때문에 오름차순 정렬을 한뒤 같은 인덱스끼리의 곱을 구하면 된다.

## 5. 궁금한 점

- 없습니다.