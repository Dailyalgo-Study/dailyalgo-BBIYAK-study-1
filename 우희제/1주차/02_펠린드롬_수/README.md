# 02. 팰린드롬 수

## 1. 문제 정보
- [데일리알고 - 팰린드롬 수](https://dailyalgo.kr/problems/158)

## 2. 소요 시간
- 1시간

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제를 어떻게 이해했고, 어떤 접근 방법을 떠올렸는지 설명합니다.

먼저 숫자의 각 자릿수를 구한 후 배열에 담아서 비교하는 것을 생각했습니다.
1. 숫자 n을 자릿수로 쪼개고 저장하기
2. 배열의 앞 인덱스가 뒤 인덱스보다 작을 때까지 반복하며 두 인덱스의 값 비교하기
3. 같다면 인덱스 증가/감소 후 다시 비교
4. begin과 back 값을 비교하여 다르면 false
5. 전부 통과 되면 true 반환한다.

처음엔 front()와 back()을 지우면서 비교하려고 했으나 pop_back만 있다는 걸 깨닫고 인덱스로 접근하는 것으로 바꿨습니다.

### ⚙️ 구현 로직의 동작 과정
> 구현한 코드가 어떤 방식으로 동작하는지, 각 단계별로 설명합니다.

1. n의 숫자를 자릿수 별로 저장하기 위해 일의 자리를 구한 후 10으로 나눠 반복을 돌면서 numbers에 저장한다.
2. numbers의 앞의 인덱스와 뒤의 인덱스의 값이 다를 때 까지 비교한다.
3. 다르다면 false를 반환, 반복문이 끝날 때까지 같다면 true반환한다. 

### ✅ 엣지 케이스에 대한 고려 사항
> 문제 해결 시 고려해야 할 특수한 경우들과 그에 대한 처리 방법을 설명합니다.


## 4. 어려웠던 점 및 해결 과정

- 어려웠던 점 1
	- n의 자릿수를 어떻게 쪼개야 할지 몰라서 고민을 오래 했습니다. 우선 나머지 연산자를 이용해 n % 10으로 일의 자리를 구하였습니다.
	- 그 다음 일의 자리를 제외한 값을 구해야 한다 생각했더니 10으로 나눈 값을 n에 저장했습니다. 
	- 이렇게 반복하면 되겠다 싶어 n이 0보다 클 때까지 반복 할 수 있게 while문을 사용했습니다.

- 어려웠던 점 2
	- frontindex와 backindex를 0과 numbers.size()로 초기화 한 후 numbers의 해당 인덱스 값을 비교하려 했다가 범위 오류가 발생했습니다.
	- 인덱스의 유효한 값은 0부터 numbers.size() - 1 이기 때문에 numbers.size()로 초기화 한 부분을 수정하여 오류를 해결했습니다.

## 5. 궁금한 점

- 문자열로도 구하는 방법이 있을까요?! 문자열을 잘 몰라서 못했습니다.