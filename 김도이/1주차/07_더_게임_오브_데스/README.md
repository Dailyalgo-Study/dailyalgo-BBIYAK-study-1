# 07. 더 게임 오브 데스

## 1. 문제 정보
- [데일리알고 - 더 게임 오브 데스](https://dailyalgo.kr/problems/170)

## 2. 소요 시간
- 21분

## 3. 풀이 설명
### 💡 아이디어 도출 과정
> 문제 읽자마자 무작정 의사코드를 적으려고 키보드를 잡지 말고, 이번엔 테스트케이스 설명 흐름을 직접 노트에 손으로 적어가며
> 이해를 먼저 해보기로 결정했다.<br>
> k회 반복문을 돌면 되겠다는 생각이 들었고,<br>
> 첫회는 무조건 1번유저부터 시작하니 분기문을 줘야겠다고 생각했고,<br>
> 그 다음회차부터 k번째까지는 쭉 분기문의 반대(else문) 으로 돌려야겠다고 생각했다.<br>
> 각 유저의 차례에선(조건문 내부 실행할 작업), pickedUser라는 변수에 본인이 미리 골라둔 유저번호를 target[]에서 찾아 저장하고,
> 매 차례 pickedUser는 갱신되며(해당 차례의 유저는 미리 정해둔 타 유저를 지목하는 순서가 진행됨)
> 반복문이 끝났을 때 마지막 pickedUser의 값이 정답이라고 생각했다.

### ⚙️ 구현 로직의 동작 과정
> 1. 지목당한 유저번호를 저장할 pickedUser를 선언한다.(초기값은 상관없지만 그냥 0으로 함)
> 2. 반복문을 k회 돌며,
> 3. 첫 반복회차만(1번유저부터 시작해야 하므로) if (i==0) 분기문으로 pickedUser=target[i]로 1번유저가 정해둔 지목대상(target[0])을 갱신한다.
> 4. 다음 회차부터는 3에서 만든 분기문의 반대인 else 분기를 타게 만들고,
> 5. pickedUser=target[pickedUser-1] (지목당한유저=본인이 정해둔 지목대상)로 계속 갱신한다.
> 6. 반복문이 끝난 후 pickedUser가 마지막 지목당한 유저번호로, 정답이 된다.

### ✅ 엣지 케이스에 대한 고려 사항
> 첫 반복 회차만 분기문이던 해서 첫 1번만 다른 처리를 해 주는 것이 포인트였다고 생각한다.


## 4. 어려웠던 점 및 해결 과정
> 여태까지는 문제 풀어 해치우기에 급급해서 성공나오면 바로 README.md 노트만 적고 커밋하면서 남은 문제 수를 쳐내가기 바빴는데,
> 과제의 절반을 하고 나서 이제서야 예시답안을 올려주셨던 게 기억이 나서, 강사님이 주신 답안과 비교해봐야 겠다는 생각을 했다.
> 나는 `int pickedUser = 0;` 로 처음에 아무 생각없이 상관없을 것 같아서 0으로 초기화해서 변수를 선언했는데,<br>
> 강사님 정답코드를 보니, 그냥 내가 if (i==0)으로 첫회차를 분기문 태운 걸 -> `int current = 1;`로 처음 변수 생성 시 1번유저일 수 있게 정보를 저장하셨고,<br>
> 그걸 활용해 반복문 안에선 나처럼 if {} 와 else {} 로 두 분기를 만들지 않고 무척 컴팩트하게 current = target[current-1]; 만으로 모든 경우를 커버했다.
> 남의 코드를 보고 다른 점을 파악하고, 더 나은 풀이가 있음을 공부하는 과정도 정말 중요하구나를 깨달았다!

## 5. 궁금한 점
> 없다.